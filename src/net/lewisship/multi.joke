(ns net.lewisship.multi
  "Support for multiple independant sub-commands within a single Joker script."
  (:require
   [joker.tools.cli :as cli]
   [joker.string :as str]
   [joker.os :as os]))

;; TODO:
;; Add :default and maybe :default-fn
;; Maybe invert :optional and :required to align with j.t.cli
;; Validate that argument ids are unique

(defmacro ^:private cond-let
  [& clauses]
  (cond
    (empty? clauses)
    nil

    (not (even? (count clauses)))
    (throw (ex-info (str `cond-let " requires an even number of forms")
                    {:form &form
                     :meta (meta &form)}))

    :else
    (let [[test expr-or-binding-form & more-clauses] clauses]
      (if (= :let test)
        `(let ~expr-or-binding-form (cond-let ~@more-clauses))
            ;; Standard case
        `(if ~test
           ~expr-or-binding-form
           (cond-let ~@more-clauses))))))

(defn ^:private show-errors
  [errors]
  (when (seq errors)
    (println)
    (println (if (= 1 (count errors)) "Error:" "Errors:"))
    (doseq [e errors]
      (println (str "  " e)))))

(defn ^:private show-tool-help
  [parsed-opts errors]
  (let [{:keys [tool-name ::command-map]} parsed-opts
        ks (-> command-map keys sort)
        width (+ 2 (apply max (map count ks)))]
    (println "Usage:" tool-name "COMMAND ...")
    (println)
    (println "Commands:")
    (doseq [k ks
            :let [doc-string (-> command-map (get k) meta :doc (or ""))
                  first-doc (-> doc-string str/split-lines first)]]
      (println (str (str/pad-left k " " width) ": " first-doc))))
  (show-errors errors))

(defn ^:private help
  "Lists available commands"
  [parsed-opts]
  (show-tool-help parsed-opts nil))

(defn locate-commands
  "Locates commands, function with the :command metadata.

  Returns a map from string name to command Var."
  [namespace-symbols]
  (let [f (fn [m namespace-symbol]
             ;; Ensure the namespace is loaded
            (require namespace-symbol)
            (->> (find-ns namespace-symbol)
                 ns-map
                 (reduce (fn [m [sym v]]
                           (if (-> v meta :command)
                             (let [command-name (or (-> v meta :command-name)
                                                    (name sym))]
                               (assoc m command-name v))
                             m))
                         m)))]
    (reduce f {} namespace-symbols)))

(defn ^:private arg-spec->str
  [arg-spec]
  (let [{:keys [label optional repeatable]} arg-spec]
    (apply str
           (when optional "[")
           label
           (when optional "]")
           (when repeatable
             (if optional "*" "+")))))

(defn ^:private indentation-of-line
  [line]
  (if (str/blank? line)
    [0 ""]
    (let [[_ indent text] (re-matches #"(\s+)(.*)" line)]
      (if
       (some? indent)
        [(count indent) text]
        [0 line]))))

(defn ^:private strip-indent [strip-chars [indent text]]
  (if (<= indent  strip-chars)
    text
    (str (apply str (repeat (- indent strip-chars) " "))
         text)))

(defn ^:private cleanup-docstring
  [docstring]
  (let [docstring' (str/trim docstring)
        lines (->> docstring'
                   str/split-lines
                   (map indentation-of-line))
        non-zero-indents (->> lines
                              (map first)
                           (remove zero?))]
    (if (empty? non-zero-indents)
      docstring'
      (let [indentation (reduce min non-zero-indents)]
        (->> lines
          (mapv #(strip-indent indentation %))
          (str/join "\n"))))))

(defn show-summary
  "Displays the command's summary; partially generated by joker.tools.cli, and then
  enhanced with more information about command line arguments.

  Uses the command map that is passed to a command function.

  errors is a seq of strings to display as errors."
  [command-map errors]
  (let [{:keys [tool-name command-name summary ::positional-specs doc]} command-map]
    (apply println
           (remove nil? (concat ["Usage:" tool-name command-name
                                 "[OPTIONS]"]
                                (map arg-spec->str positional-specs))))
    (when doc
      (-> doc cleanup-docstring println))

    ;; There's always at least -h/--help:
    (println "\nOptions:")
    (println summary)

    (when (seq positional-specs)
      (let [label-width (->> positional-specs
                             (map :label)
                             (map count)
                             (reduce max)
                                ;; For indentation
                             (+ 2))]
        (println "\nArguments:")
        (doseq [{:keys [label doc]} positional-specs]
          (println (str
                    (str/pad-left label " " label-width)
                    ": "
                    doc)))))

    (show-errors errors)))

(defn ^:private compile-positional-spec
  "Positional specs are similar to option specs."
  [command-name terms]
  (let [[label & more] terms]
    ;; The label is required, then it's the optional documentation string
    (if (-> more first string?)
      (recur command-name
             (into [label :doc (first more)]
                   (rest more)))
      (let [spec-map (apply hash-map more)
            id (or (:id spec-map)
                   (-> label str/lower-case keyword))
            invalid-keys (-> spec-map
                             (dissoc :id :doc :optional :repeatable :default :parse-fn :update-fn :assoc-fn :validate)
                             keys
                             sort)
            {:keys [validate update-fn repeatable doc optional parse-fn assoc-fn]} spec-map
            _ (when (and update-fn assoc-fn)
                (throw (ex-info "May only specify one of :update-fn and :assoc-fn"
                                {:command-name command-name
                                 :spec spec-map})))
            assoc-fn' (cond
                        assoc-fn
                        assoc-fn

                        update-fn
                        (fn [m k v]
                          (update m k update-fn v))

                        repeatable
                        (fn [m k v]
                          (update m k (fnil conj []) v))

                        :else
                        assoc)
            validate-pairs (when (seq validate)
                             (->> (partition 2 2 validate)
                                  (map vec)))]
        (when (seq invalid-keys)
          (println-err (format "Warning: command %s, argument %s contains invalid key(s): %s"
                               command-name
                               id
                               (str/join ", " invalid-keys))))
        {:label label
         :id id
         :doc doc
         :optional optional
         :repeatable repeatable
         :assoc-fn assoc-fn'
         :parse-fn (or parse-fn identity)
         :validate validate-pairs}))))

(defn ^:private compile-position-specs
  [command-name specs]
  (let [compiled (map #(compile-positional-spec command-name %) specs)]
    (loop [[this-spec & more-specs] compiled
           ids #{}
           optional-id nil
           repeatable-id nil]
      (cond-let
       (nil? this-spec)
       compiled

       :let [this-id (:id this-spec)]

       (contains? ids this-id)
       (throw (ex-info (str "Argument " this-id " of command " command-name " is not unique")
                       {:command-name command-name
                        :spec this-spec}))

       ;; Use the keyword ids, not the labels, since these are a programmer errors, not a runtime error

       (and optional-id
            (not (:optional this-spec)))
       (throw (ex-info (str "Argument " this-id " of command " command-name " is not optional but follows optional argument " optional-id)
                       {:command-name command-name
                        :spec this-spec}))

       (some? repeatable-id)
       (throw (ex-info (str "Argument " this-id " of command " command-name " follows repeatable argument " repeatable-id ", but only the final argument may be repeatable")
                       {:command-name command-name
                        :spec this-spec}))

       :else
       (recur more-specs
              (conj ids this-id)
              (or (when (:optional this-spec)
                    this-id)
                  optional-id)
              (or (when (:repeatable this-spec)
                    this-id)
                  repeatable-id))))))

(defn ^:private validate-argument
  "Validates the value against the :validate vector of the spec, returning nil on
   success, or the first error.  A validation fn that returns false or throws an exception
   is a failure."
  [positional-spec value]
  (loop [[tuple & more] (:validate positional-spec)]
    (when tuple
      (let [[validation-fn validation-msg] tuple]
        (if-not (try
                  (validation-fn value)
                  (catch Error _ false))
          validation-msg
          (recur more))))))

(defn ^:private process-arguments
  [positional-specs arguments]
  (loop [state {:specs positional-specs
                :remaining arguments
                :argument-map {}
                :errors []
                :ignore-required false}]
    (cond-let
     :let [{:keys [specs remaining argument-map errors ignore-required]} state
           [this-spec & more-specs] specs
           {:keys [label repeatable optional parse-fn assoc-fn id]} this-spec
           [this-argument & more-arguments] remaining]

     ;; specs and arguments exhausted
     (and (nil? this-spec)
          (nil? this-argument))
     [argument-map errors]

     ;; Hit the first optional argument and out of command line arguments.
     ;; Since all subsequent arguments must be optional (verified by compile), we can stop here.
     (and (nil? this-argument)
          ;; After the first argument is consumed by a repeatable, we treat the repeatable
          ;; command as optional.
          (or optional ignore-required))
     [argument-map errors]

     ;; Have a required argument and nothing to match it against.
     (nil? this-argument)
     [argument-map (conj errors (str "No value for required argument " label))]

     ;; Ran out of specs before running out of arguments.
     (nil? this-spec)
     [argument-map (conj errors (format "Unexpected argument '%s'" this-argument))]

     :let [[parsed error] (try
                            [(parse-fn this-argument) nil]
                            (catch Error t
                              [nil (format "Error in %s: %s" label (ex-message t))]))]

     error
     [argument-map (conj errors error)]

     :let [validation-errors (validate-argument this-spec parsed)]

     (seq validation-errors)
     [argument-map (into errors validation-errors)]

     :else
     (let [state' (assoc state
                         ;; Consume an argument
                         :remaining more-arguments
                         ;; Apply the argument
                         :argument-map (assoc-fn argument-map id parsed))]
       (recur (if repeatable
                ;; leave the last, repeatable spec in place
                (assoc state' :ignore-required true)
                ;; Not repeatable; it has "consumed" an argument, so continue with
                ;; next spec and next argument
                (assoc state' :specs more-specs)))))))

(defn dispatch*
  "Executes a command from a multi-tool; this is normally invoked via dispatch, using
   the commands map (map of command names to command Vars) and the command line arguments
   (the first argument is used to select the command to execute.)"
  [tool-name commands command-line-args]
  (cond-let

   :let [[command-name] command-line-args
         base-command-map {:tool-name tool-name
                           ::command-map commands}]

   (or (nil? command-name)
       (str/starts-with? command-name "-"))
   (do
     (show-tool-help base-command-map ["No command provided"])
     (os/exit 1))

   :let [command-var (get commands command-name)]

   (nil? command-var)
   (show-tool-help base-command-map
                   [(format "'%s' is not a command" command-name)])

   :let [var-meta (meta command-var)
         positional-specs (compile-position-specs command-name (:command-args var-meta))
         command-map (merge base-command-map
                            (cli/parse-opts (rest command-line-args)
                                            (conj (:command-opts var-meta)
                                                  ["-h" "--help" "This command summary"]))
                            {:command-name command-name
                             ::positional-specs positional-specs
                             :doc (:doc var-meta)})
         {:keys [options arguments]
          opt-errors :errors} command-map
         [processed-arguments arg-errors] (process-arguments positional-specs arguments)
         errors (concat opt-errors arg-errors)]

   (:help options)
   (show-summary command-map nil)

   (seq errors)
   (do
     (show-summary command-map errors)
     (os/exit 1))

   :else
   (command-var (assoc command-map :arguments processed-arguments))))

(defn dispatch
  "Locates commands in namespaces, finds the current command
  (as identified by the first command line argument) and processes CLI options and arguments.

  configuration keys:
  :tool-name (required, string) - used in command summary and errors
  :arguments - command line arguments to parse (defaults to *command-line-args*)
  :namespaces - symbols identifying namespaces to search for commands

  dispatch will load any namespaces specified.

  If option and argument parsing is unsuccesful, then
  a command usage summary is printed, along with errors, and the program exits
  with error code 1.

  On success, the command function is invoked with a command map:

  :tool-name - the name of the tool (useful for error messages)
  :command-name - the name of the command
  :options - map of command line options (via joker.tools.cli/parse-opts)
  :arguments - map of processed command line arguments
  :doc - the documentation (docstring) of the comamnd

  Other keys may be present in the command map; these are internal to
  joker.tools.multi and may change in the future."
  [configuration]
  (try
    (let [{:keys [tool-name]
           namespace-symbols :namespaces
           command-line-args :arguments
           :or {command-line-args *command-line-args*}} configuration
          command-map (assoc
                       (locate-commands namespace-symbols)
                       "help" #'help)]
      (dispatch* tool-name command-map command-line-args))
    (catch Error t
      (println-err "Command failed:" t)
      (when-let [data (ex-data t)]
        (binding [*out* *err*]
          (pprint data)))
      (os/exit 1))))
