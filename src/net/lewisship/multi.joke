;;  Copyright 2019-present Howard M. Lewis Ship
;;
;;  Licensed under the Apache License, Version 2.0 (the "License");
;;  you may not use this file except in compliance with the License.
;;  You may obtain a copy of the License at
;;
;;      http://www.apache.org/licenses/LICENSE-2.0

(ns net.lewisship.multi
  "Support for multiple independant sub-commands within a single Joker script."
  (:require
   [joker.tools.cli :as cli]
   [joker.string :as str]
   [joker.better-cond :as b]
   [joker.os :as os]))

;; TODO:
;; Add :default and maybe :default-fn
;; Maybe invert :optional and :required to align with j.t.cli
;; Validate that argument ids are unique
;; Identify command from unique prefix

(defn ^:private show-errors
  [errors]
  (when (seq errors)
    (println)
    (println (if (= 1 (count errors)) "Error:" "Errors:"))
    (doseq [e errors]
      (println (str "  " e)))))

(defn collect
  "Used as the :assoc-fn for repeatable options/arguments that collect a series of values into a vector."
  [m k v]
  (update m k #(conj (or % []) v)))

(defn locate-commands
  "Locates commands, function with the :command metadata.

  Returns a map from string name to command Var."
  [namespace-symbols]
  (let [f (fn [m namespace-symbol]
             ;; Ensure the namespace is loaded
            (require namespace-symbol)
            (->> (find-ns namespace-symbol)
                 ns-map
                 (reduce (fn [m [sym v]]
                           (if (-> v meta :command)
                             (let [command-name (or (-> v meta :command-name)
                                                    (name sym))]
                               (assoc m command-name v))
                             m))
                         m)))]
    (reduce f {} namespace-symbols)))

(defn ^:private arg-spec->str
  [arg-spec]
  (let [{:keys [label optional repeatable]} arg-spec]
    (apply str
           (when optional "[")
           label
           (when optional "]")
           (when repeatable
             (if optional "*" "+")))))

(defn ^:private indentation-of-line
  [line]
  (if (str/blank? line)
    [0 ""]
    (let [[_ indent text] (re-matches #"(\s+)(.*)" line)]
      (if
       (some? indent)
        [(count indent) text]
        [0 line]))))

(defn ^:private strip-indent [strip-chars [indent text]]
  (if (<= indent  strip-chars)
    text
    (str (apply str (repeat (- indent strip-chars) " "))
         text)))

(defn ^:private cleanup-docstring
  [docstring]
  (let [docstring' (str/trim docstring)
        lines (->> docstring'
                   str/split-lines
                   (map indentation-of-line))
        non-zero-indents (->> lines
                              (map first)
                              (remove zero?))]
    (if (empty? non-zero-indents)
      docstring'
      (let [indentation (reduce min non-zero-indents)]
        (->> lines
             (mapv #(strip-indent indentation %))
             (str/join "\n"))))))

(defn show-summary
  "Displays the command's summary; partially generated by joker.tools.cli, and then
  enhanced with more information about command line arguments.

  Uses the command map that is passed to a command function.

  When using `defcommand`, an :as clause in the interface gives access to this
  command map.

  errors is a seq of strings to display as errors."
  [command-map errors]
  (let [{:keys [::tool-name ::tool-doc ::command-name summary ::positional-specs ::doc]} command-map]
    (apply println
           (remove nil? (concat ["Usage:" tool-name command-name
                                 "[OPTIONS]"]
                                (map arg-spec->str positional-specs))))

    (when doc
      (-> doc cleanup-docstring println))

    ;; There's always at least -h/--help:
    (println "\nOptions:")
    (println summary)

    (when (seq positional-specs)
      (let [label-width (->> positional-specs
                             (map :label)
                             (map count)
                             (reduce max)
                                ;; For indentation
                             (+ 2))]
        (println "\nArguments:")
        (doseq [{:keys [label doc]} positional-specs]
          (println (str
                    (str/pad-left label " " label-width)
                    ": "
                    doc)))))

    (show-errors errors)))

(defn ^:private show-tool-help
  [parsed-opts errors]
  (let [{:keys [::tool-name ::tool-doc ::command-map]} parsed-opts
        ks (-> command-map keys sort)
        width (+ 2 (apply max (map count ks)))]
    (println "Usage:" tool-name "COMMAND ...")
    (when tool-doc
      (println)
      (-> tool-doc cleanup-docstring println))

    (println)
    (println "Commands:")
    (doseq [k ks
            :let [doc-string (-> command-map (get k) meta :doc (or ""))
                  first-doc (-> doc-string str/split-lines first)]]
      (println (str (str/pad-left k " " width) ": " first-doc))))
  (show-errors errors))

(defn ^:private help
  "Lists available commands"
  [parsed-opts]
  (show-tool-help parsed-opts nil))

(defn ^:private compile-positional-spec
  "Positional specs are similar to option specs."
  [command-name terms]
  (let [[label & more] terms]
    ;; The label is required, then it's the optional documentation string
    (if (-> more first string?)
      (recur command-name
             (into [label :doc (first more)]
                   (rest more)))
      (let [spec-map (apply hash-map more)
            id (or (:id spec-map)
                   (-> label str/lower-case keyword))
            invalid-keys (-> spec-map
                             (dissoc :id :doc :optional :repeatable :default :parse-fn :update-fn :assoc-fn :validate)
                             keys
                             sort)
            {:keys [validate update-fn repeatable doc optional parse-fn assoc-fn]} spec-map
            _ (when (and update-fn assoc-fn)
                (throw (ex-info "May only specify one of :update-fn and :assoc-fn"
                                {:command-name command-name
                                 :spec spec-map})))
            assoc-fn' (cond
                        assoc-fn
                        assoc-fn

                        update-fn
                        (fn [m k v]
                          (update m k update-fn v))

                        repeatable
                        (fn [m k v]
                          (update m k (fnil conj []) v))

                        :else
                        assoc)]
        (when (seq invalid-keys)
          (println-err (format "Warning: command %s, argument %s contains invalid key(s): %s"
                               command-name
                               id
                               (str/join ", " invalid-keys))))
        {:label label
         :id id
         :doc doc
         :optional optional
         :repeatable repeatable
         :assoc-fn assoc-fn'
         :parse-fn (or parse-fn identity)
         :validate validate}))))

(defn ^:private compile-position-specs
  [command-name specs]
  (let [compiled (map #(compile-positional-spec command-name %) specs)]
    (loop [[this-spec & more-specs] compiled
           ids #{}
           optional-id nil
           repeatable-id nil]
      (b/cond
        (nil? this-spec)
        compiled

        :let [this-id (:id this-spec)]

        (contains? ids this-id)
        (throw (ex-info (str "Argument " this-id " of command " command-name " is not unique")
                        {:command-name command-name
                         :spec this-spec}))

       ;; Use the keyword ids, not the labels, since these are a programmer errors, not a runtime error

        (and optional-id
             (not (:optional this-spec)))
        (throw (ex-info (str "Argument " this-id " of command " command-name " is not optional but follows optional argument " optional-id)
                        {:command-name command-name
                         :spec this-spec}))

        (some? repeatable-id)
        (throw (ex-info (str "Argument " this-id " of command " command-name " follows repeatable argument " repeatable-id ", but only the final argument may be repeatable")
                        {:command-name command-name
                         :spec this-spec}))

        :else
        (recur more-specs
               (conj ids this-id)
               (or (when (:optional this-spec)
                     this-id)
                   optional-id)
               (or (when (:repeatable this-spec)
                     this-id)
                   repeatable-id))))))

(defn ^:private validate-argument
  "Validates the value against the :validate vector of the spec, returning nil on
   success, or the first error.  A validation fn that returns false or throws an exception
   is a failure."
  [positional-spec value]
  (loop [[validation-fn validation-msg & more] (:validate positional-spec)]
    (when validation-fn
      (if-not (try
                (validation-fn value)
                (catch Error _ false))
        validation-msg
        (recur more)))))

(defn ^:private process-arguments
  [positional-specs arguments]
  (loop [state {:specs positional-specs
                :remaining arguments
                :argument-map {}
                :errors []
                :ignore-required false}]
    (b/cond
      :let [{:keys [specs remaining argument-map errors ignore-required]} state
            [this-spec & more-specs] specs
            {:keys [label repeatable optional parse-fn assoc-fn id]} this-spec
            [this-argument & more-arguments] remaining]

     ;; specs and arguments exhausted
      (and (nil? this-spec)
           (nil? this-argument))
      [argument-map errors]

     ;; Hit the first optional argument and out of command line arguments.
     ;; Since all subsequent arguments must be optional (verified by compile), we can stop here.
      (and (nil? this-argument)
          ;; After the first argument is consumed by a repeatable, we treat the repeatable
          ;; command as optional.
           (or optional ignore-required))
      [argument-map errors]

     ;; Have a required argument and nothing to match it against.
      (nil? this-argument)
      [argument-map (conj errors (str "No value for required argument " label))]

     ;; Ran out of specs before running out of arguments.
      (nil? this-spec)
      [argument-map (conj errors (format "Unexpected argument '%s'" this-argument))]

      :let [[parsed error] (try
                             [(parse-fn this-argument) nil]
                             (catch Error t
                               [nil (format "Error in %s: %s" label (ex-message t))]))]

      error
      [argument-map (conj errors (str label ": "  error))]

      :let [validation-error (validate-argument this-spec parsed)]

      (some? validation-error)
      [argument-map (conj errors (str label ": " validation-error))]

      :else
      (let [state' (assoc state
                         ;; Consume an argument
                          :remaining more-arguments
                         ;; Apply the argument
                          :argument-map (assoc-fn argument-map id parsed))]
        (recur (if repeatable
                ;; leave the last, repeatable spec in place
                 (assoc state' :ignore-required true)
                ;; Not repeatable; it has "consumed" an argument, so continue with
                ;; next spec and next argument
                 (assoc state' :specs more-specs)))))))

(defn ^:private find-matches
  [m s]
  ;; If can find an exact match, then keep just that;
  (if (get m s)
    [s]
    ;; Otherwise, look for command names prefixed by the string
    (->> m
         keys
         (filter #(str/starts-with? % s)))))

(defn dispatch*
  "Executes a command from a multi-tool; this is normally invoked via dispatch, using
  the commands map (map of command names to command Vars) and the command line arguments
  (the first argument is used to select the command to execute.)

  Options:
  :tool-name - name of tool, used in usage
  :tool-doc - documentation for the tool, used in usage
  :commands - map of string to Var; each Var is a command
  :args - seq of strings, command line arguments to parse

  Note: the 3 argument arity of this fn is deprecated and may be removed in the future."
  ([tool-name commands args]
   (dispatch* {:tool-name tool-name
               :commands commands
               :args args}))
  ([options]
   (b/cond

     :let [{:keys [tool-name tool-doc commands args]} options
           [command-name & command-args] args
           base-command-map {::tool-name tool-name
                             ::tool-doc tool-doc
                             ::command-map commands}]

     (or (nil? command-name)
         (str/starts-with? command-name "-"))
     (do
       (show-tool-help base-command-map ["No command provided"])
       (os/exit 1))

     :let [matching-names (find-matches commands command-name)]

     (empty? matching-names)
     (do
       (show-tool-help base-command-map
                       [(format "'%s' is not a command" command-name)])
       (os/exit 1))

     (< 1 (count matching-names))
     (do
       (show-tool-help base-command-map
                       [(format "'%s' matches commands %s"
                                command-name
                                (->> matching-names
                                     sort
                                     (str/join ", ")))])
       (os/exit 1))

     :let [matching-name (first matching-names)
           command-var (get commands matching-name)
           var-meta (meta command-var)
           positional-specs (compile-position-specs command-name (:command-args var-meta))
           command-map (merge base-command-map
                              (cli/parse-opts command-args
                                              (conj (:command-opts var-meta)
                                                    ["-h" "--help" "This command summary"]))
                              {::command-name matching-name
                               ::positional-specs positional-specs
                               ::doc (:doc var-meta)})
           {:keys [options arguments]
            opt-errors :errors} command-map
           [processed-arguments arg-errors] (process-arguments positional-specs arguments)
           errors (concat opt-errors arg-errors)]

     (:help options)
     (show-summary command-map nil)

     (seq errors)
     (do
       (show-summary command-map errors)
       (os/exit 1))

     :else
     (command-var (assoc command-map :arguments processed-arguments)))))

(defmacro dispatch
  "Locates commands in namespaces, finds the current command
  (as identified by the first command line argument) and processes CLI options and arguments.

  configuration keys:
  :tool-name (required, string) - used in command summary and errors
  :arguments - command line arguments to parse (defaults to *command-line-args*)
  :namespaces - symbols identifying namespaces to search for commands

  If :namespaces is omitted, it defaults to the current namespace.

  dispatch will load any namespaces specified.

  If option and argument parsing is unsuccessful, then
  a command usage summary is printed, along with errors, and the program exits
  with error code 1.

  On success, the command function is invoked with a command map:

  :options - map of command line options (via joker.tools.cli/parse-opts)
  :arguments - map of processed command line arguments

  Other keys may be present in the command map; these are internal to
  joker.tools.multi and may change in the future."
  [configuration]
  (let [default-ns (ns-name *ns*)]
    `(try
       (let [configuration# ~configuration
             namespace-symbols# (or (:namespaces configuration#)
                                    ['~default-ns])
             arguments# (or (:arguments configuration#)
                            *command-line-args*)
             command-map# (assoc
                           (locate-commands namespace-symbols#)
                           "help" #'help)]
         (dispatch* {:tool-name (:tool-name configuration#)
                     :tool-doc (or (:tool-doc configuration#)
                                   (some-> namespace-symbols# first find-ns meta :doc))
                     :commands command-map#
                     :args arguments#}))
       (catch Error t#
         (println-err "Command failed:" t#)
         (when-let [data# (ex-data t#)]
           (binding [*out* *err*]
             (pprint data#)))
         (os/exit 1)))))

;; Start of code to support defcommand:

(defn ^:private fail [message state form]
  (throw (ex-info message
                  {:state state
                   :form form})))

(defmulti ^:private consumer (fn [state _form] (:consuming state)))

(defmethod consumer :options
  [state form]
  (cond
    (keyword? form)
    (assoc state :consuming form :pending true)

    (not (simple-symbol? form))
    (fail "Expected option name symbol" state form)

    ;; Could check for uniqueness here

    :else
    (assoc state
           :symbol form
           :pending true
           :consuming :option-def)))

(defmethod consumer :option-def
  [state option-def]
  (when-not (or (symbol? option-def)
                (vector? option-def))

    (fail "Expected option definition" state option-def))

  (let [option-symbol (:symbol state)
        option-def' (list 'conj option-def :id (-> option-symbol name keyword))]
    (-> state
        (update :command-options conj option-def')
        (update :option-symbols conj option-symbol)
        (dissoc :symbol :pending)
        (assoc :consuming :options))))

(defmethod consumer :arg-def
  [state arg-def]
  (when-not (or (symbol? arg-def)
                (vector? arg-def))
    (fail "Expected argument definition" state arg-def))

  (let [arg-symbol (:symbol state)
        arg-def' (list 'conj arg-def :id (-> arg-symbol name keyword))]
    (-> state
        (update :command-args conj arg-def')
        (update :arg-symbols conj arg-symbol)
        (dissoc :symbol :pending)
        (assoc :consuming :args))))

(defmethod consumer :args
  [state form]
  (cond
    (keyword? form)
    (assoc state :consuming form :pending true)

    (not (simple-symbol? form))
    (fail "Expected argument name symbol" state form)

    ;; Could check for uniqueness here

    :else
    (assoc state
           :symbol form
           :pending true
           :consuming :arg-def)))

(defmethod consumer :as
  [state form]
  (when-not (simple-symbol? form)
    (fail "Expected command-map symbol" state form))

  (-> state
      (assoc :command-map-symbol form
             :consuming :keyword)
      (dissoc :pending)))

(defmethod consumer :keyword
  [state form]
  (when-not (keyword? form)
    (fail "Expected a keyword" state form)

    (assoc state :consuming form :pending true)))

(defmethod consumer :command-name
  [state form]
  (when-not (string? form)
    (fail "Expected string for command name" state form))

  (-> state
      (dissoc :pending)
      (assoc
       :command-name form
       :consuming :keyword)))

(defn ^:private parse-interface
  [forms]
  (let [initial-state {:consuming :options
                       :option-symbols []
                       :arg-symbols []
                       :command-options []
                       :command-args []}
        final-state (reduce consumer initial-state forms)]
    (when (:pending final-state)
      (throw (ex-info "Missing data in interface definitions"
                      {:state final-state
                       :forms forms})))
    final-state))

(defmacro defcommand
  "Defines a command for multi.

  Commands must always have a docstring.
  The first line of the docstring is the summary used by the help command.

  The interface follows, which is described in the multi readme.

  Finally, the body."
  [command-name docstring interface & body]
  (assert (simple-symbol? command-name)
          "defcommand expects a symbol for command name")
  (assert (string? docstring)
          (throw "defcommand requires a docstring"))
  (assert (vector? interface)
          "defcommand expects a vector to define the interface")
  (let [symbol-meta (meta command-name)
        parsed (parse-interface interface)
        {:keys [option-symbols command-options
                arg-symbols command-args
                command-map-symbol]
         override-command-name :command-name
         :or {command-map-symbol (gensym "command-map-")}} parsed
        all-terms (cond-> []
                    (seq option-symbols)
                    (into `[{:keys ~option-symbols} (:options ~command-map-symbol)])

                    (seq arg-symbols)
                    (into `[{:keys ~arg-symbols} (:arguments ~command-map-symbol)]))

        full-meta (cond-> (assoc symbol-meta
                                 :command true
                                 :command-opts command-options
                                 :command-args command-args
                                 :doc docstring)
                    override-command-name (assoc :command-name override-command-name))]
    `(defn ~command-name
       ~full-meta
       [~command-map-symbol]
       (let ~all-terms ~@body))))
